<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Aeros Racing ‚Äì Pit Display Software</title>
    <!-- Orbitron Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"/>
    
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background: #0c0c0c; 
            color: #fff; 
            font-family: 'Orbitron', sans-serif;
            user-select: none;
        }
        
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
            background: #0a0a0a;
            touch-action: none;
        }

        /* Home Screen */
        #homeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f32411;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 1000;
            cursor: pointer;
        }
        
        #homeScreen h1 { 
            font-size: 4rem; 
            margin-bottom: 1rem; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px #f32411; }
            to { text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 30px #f32411, 0 0 40px #f32411; }
        }
        
        .feature-container { 
            display: flex; 
            gap: 2rem; 
            margin-top: 2rem; 
            flex-wrap: wrap; 
            justify-content: center;
        }
        
        .feature-circle {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 3px solid #fff;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.5rem;
            font-size: 1rem;
            flex-direction: column;
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
            transition: transform 0.3s ease;
        }
        
        .feature-circle:hover {
            transform: scale(1.1);
            background: rgba(255,255,255,0.1);
        }
        
        .feature-icon {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        #homeScreen > p {
            margin-top: 3rem;
            font-size: 1.8rem;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ENHANCED: Top UI Bar - Professional Racing HUD Design */
        #topBar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 107px;
            background: linear-gradient(180deg, rgba(12,12,12,0.98) 0%, rgba(20,20,20,0.95) 50%, rgba(12,12,12,0.92) 100%);
            border-bottom: 3px solid #cc0000;
            box-shadow: 0 0 20px rgba(204,0,0,0.3), 0 5px 25px rgba(0,0,0,0.8);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 35px;
            backdrop-filter: blur(15px);
        }

        .iteration-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            flex: 1;
            min-width: 220px;
            max-width: 280px;
        }
        
        .iteration-title {
            font-size: 1.7rem;
            font-weight: 700;
            color: #cc0000;
            text-shadow: 0 0 15px rgba(204,0,0,0.8), 0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 0.5px;
        }
        
        .iteration-subtitle {
            font-size: 1rem;
            color: #bbb;
            font-weight: 400;
            text-shadow: 0 1px 3px rgba(0,0,0,0.7);
        }
        
        .iteration-selector-floating {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 600;
        }
        
        .iteration-dropdown {
            background: linear-gradient(145deg, rgba(25, 25, 25, 0.95), rgba(15, 15, 15, 0.95));
            border: 2px solid #cc0000;
            border-radius: 12px;
            color: #fff;
            font-size: 1rem;
            font-weight: 700;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            box-shadow: 0 4px 15px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .iteration-dropdown:hover {
            border-color: #ff3333;
            box-shadow: 0 0 20px rgba(204,0,0,0.6), 0 6px 20px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }
        
        .iteration-dropdown:focus {
            outline: none;
            border-color: #ff3333;
            box-shadow: 0 0 25px rgba(204,0,0,0.8), 0 8px 25px rgba(0,0,0,0.9), inset 0 1px 0 rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        /* Use high-contrast friendly colors for native Windows dropdown menu */
        .iteration-dropdown option {
            background: #ffffff; /* many platforms ignore this but safe */
            color: #000000;      /* ensure readable on white native menus */
            padding: 12px 16px;
            font-weight: 600;
            border: none;
        }
        .iteration-dropdown option:hover {
            background: #f0f0f0;
            color: #000000;
        }

        /* Prefer system colors in forced-colors modes (Windows High Contrast) */
        @media (forced-colors: active) {
            .iteration-dropdown {
                forced-color-adjust: none;
                color: ButtonText;
                background: ButtonFace;
                border-color: ButtonText;
            }
            .iteration-dropdown option {
                color: ButtonText;
                background: ButtonFace;
            }
        }

        /* ENHANCED: Professional Racing-Style Center Controls */
        .center-controls {
            display: flex;
            align-items: center;
            gap: 18px;
            padding: 12px 28px;
            background: linear-gradient(145deg, rgba(25,25,25,0.95), rgba(15,15,15,0.9));
            border: 2px solid #cc0000;
            border-radius: 35px;
            box-shadow: 
                0 4px 20px rgba(0,0,0,0.6),
                inset 0 1px 2px rgba(255,255,255,0.1),
                0 0 30px rgba(204,0,0,0.2);
            flex: 0 0 auto;
            position: relative;
        }

        .center-controls::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg, transparent, rgba(204,0,0,0.3), transparent);
            border-radius: 35px;
            z-index: -1;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            position: relative;
        }

        .control-label {
            color: #ddd;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            text-align: center;
            min-width: 75px;
            line-height: 1;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        .ui-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(40,40,40,0.9), rgba(20,20,20,0.8));
            border: 2px solid rgba(204,0,0,0.4);
            color: white;
            box-shadow: 
                0 3px 10px rgba(0,0,0,0.4),
                inset 0 1px 2px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }

        .ui-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(204,0,0,0.3), transparent);
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            border-radius: 50%;
        }

        .ui-button:hover::before {
            width: 100%;
            height: 100%;
        }

        /* Enhanced individual button styles */
        #auto {
            background: linear-gradient(135deg, rgba(204,0,0,0.3), rgba(180,0,0,0.2));
            border-color: rgba(204,0,0,0.6);
        }

        #auto:hover {
            background: linear-gradient(135deg, rgba(204,0,0,0.6), rgba(255,0,0,0.4));
            border-color: #cc0000;
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(204,0,0,0.6), 0 5px 15px rgba(0,0,0,0.5);
        }

        #auto.active {
            background: linear-gradient(135deg, #cc0000, #ff0000);
            border-color: #fff;
            box-shadow: 0 0 30px rgba(204,0,0,0.9), 0 5px 20px rgba(0,0,0,0.6);
            animation: auto-pulse 2s ease-in-out infinite;
        }

        @keyframes auto-pulse {
            0%, 100% { box-shadow: 0 0 30px rgba(204,0,0,0.9), 0 5px 20px rgba(0,0,0,0.6); }
            50% { box-shadow: 0 0 40px rgba(255,0,0,1), 0 7px 25px rgba(0,0,0,0.7); }
        }

        #liveryBtn {
            background: linear-gradient(135deg, rgba(204,102,0,0.3), rgba(180,90,0,0.2));
            border-color: rgba(204,102,0,0.6);
        }

        #liveryBtn:hover {
            background: linear-gradient(135deg, rgba(204,102,0,0.6), rgba(255,136,0,0.4));
            border-color: #cc6600;
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(204,102,0,0.6), 0 5px 15px rgba(0,0,0,0.5);
        }

        #liveryBtn.active {
            background: linear-gradient(135deg, #cc6600, #ff8800);
            border-color: #fff;
            box-shadow: 0 0 30px rgba(255,136,0,0.9), 0 5px 20px rgba(0,0,0,0.6);
        }

        #windTunnelBtn {
            background: linear-gradient(135deg, rgba(0,102,204,0.3), rgba(0,90,180,0.2));
            border-color: rgba(0,102,204,0.6);
            position: relative;
        }

        #windTunnelBtn:hover {
            background: linear-gradient(135deg, rgba(0,102,204,0.6), rgba(0,136,255,0.4));
            border-color: #0066cc;
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(0,136,255,0.6), 0 5px 15px rgba(0,0,0,0.5);
        }

        #windTunnelBtn.active {
            background: linear-gradient(135deg, #00cc00, #00ff00);
            border-color: #fff;
            box-shadow: 0 0 30px rgba(0,255,0,0.9), 0 5px 20px rgba(0,0,0,0.6);
            animation: wind-flow 2s ease-in-out infinite;
        }

        #resetBtn {
            background: linear-gradient(135deg, rgba(80,80,80,0.3), rgba(60,60,60,0.2));
            border-color: rgba(150,150,150,0.6);
        }

        #resetBtn:hover {
            background: linear-gradient(135deg, rgba(120,120,120,0.6), rgba(150,150,150,0.4));
            border-color: #999;
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(150,150,150,0.4), 0 5px 15px rgba(0,0,0,0.5);
        }

        /* ENHANCED: Specs info with better styling */
        .specs-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
            flex: 1;
            min-width: 220px;
            max-width: 280px;
        }
        
        .spec-line {
            font-size: 0.95rem;
            color: #ddd;
            text-align: right;
            line-height: 1.3;
            text-shadow: 0 1px 3px rgba(0,0,0,0.7);
            padding: 2px 8px;
            background: linear-gradient(90deg, transparent, rgba(204,0,0,0.1));
            border-radius: 4px;
            min-width: 150px;
        }
        
        .spec-highlight {
            color: #cc0000;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(204,0,0,0.5);
        }
        
        /* Walkthrough Button - Detached */
        #walkthroughButton {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: auto;
            height: 50px;
            padding: 0 25px;
            border-radius: 25px;
            background: linear-gradient(135deg, #cc0000, #ff0000);
            border: 2px solid #fff;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 600;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(204,0,0,0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #walkthroughButton:hover {
            background: linear-gradient(135deg, #ff0000, #ff3333);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(204,0,0,0.8);
        }
        
        #walkthroughButton.active {
            background: linear-gradient(135deg, #00cc00, #00ff00);
            animation: pulse-walkthrough 2s ease-in-out infinite;
        }
        
        @keyframes pulse-walkthrough {
            0%, 100% { box-shadow: 0 4px 15px rgba(0,204,0,0.6); }
            50% { box-shadow: 0 6px 25px rgba(0,255,0,0.8); }
        }

        /* Walkthrough Subtitles */
        #walkthroughSubtitles {
            position: fixed;
            top: 100px;
            right: 30px;
            background: linear-gradient(145deg, rgba(12,12,12,0.95), rgba(20,20,20,0.9));
            border: 2px solid #cc0000;
            border-radius: 15px;
            padding: 15px 20px;
            z-index: 800;
            max-width: 350px;
            min-width: 300px;
            text-align: left;
            box-shadow: 0 8px 25px rgba(0,0,0,0.8);
            backdrop-filter: blur(15px);
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.95rem;
            line-height: 1.4;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        
        #walkthroughSubtitles.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        #walkthroughSubtitles::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #cc0000, #ff0000, #cc0000);
            border-radius: 15px;
            z-index: -1;
            opacity: 0.5;
        }

        /* Navigation Arrows */
        .nav-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(204,0,0,0.9);
            display: none !important;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            cursor: pointer;
            z-index: 500;
            transition: all 0.3s ease;
            user-select: none;
            box-shadow: 0 6px 15px rgba(0,0,0,0.6);
            border: 2px solid transparent;
            color: white;
        }
        
        .nav-arrow:hover {
            background: rgba(204,0,0,1);
            transform: translateY(-50%) scale(1.15);
            border-color: #fff;
            box-shadow: 0 8px 25px rgba(204,0,0,0.8);
        }
        
        .nav-arrow.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: rgba(100,100,100,0.5);
        }
        
        .nav-arrow.disabled:hover {
            transform: translateY(-50%);
            background: rgba(100,100,100,0.5);
            border-color: transparent;
        }
        
        #prev { left: 30px; }
        #next { right: 30px; }
        
        /* Instructions Panel */
        #instructionsPanel {
            position: fixed;
            bottom: 100px;
            left: 30px;
            background: rgba(20,20,20,0.95);
            border: 2px solid #cc0000;
            border-radius: 15px;
            padding: 20px;
            z-index: 400;
            box-shadow: 0 6px 20px rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            max-width: 200px;
            font-size: 0.9rem;
            display: none;
        }
        
        #instructionsPanel h3 {
            margin-bottom: 15px;
            color: #cc0000;
            font-size: 1.1rem;
            text-align: center;
            text-shadow: 0 0 10px rgba(204,0,0,0.5);
        }
        
        #instructionsPanel ul {
            list-style: none;
            margin: 0;
        }
        
        #instructionsPanel li {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            font-size: 0.85rem;
        }
        
        .control-key {
            background: #333;
            border-radius: 6px;
            padding: 4px 8px;
            margin-right: 10px;
            font-size: 0.75rem;
            min-width: 45px;
            text-align: center;
            border: 1px solid #555;
        }
        
        /* Loading Spinner */
        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 6px solid rgba(204,0,0,0.3);
            border-top: 6px solid #cc0000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 750;
            box-shadow: 0 0 30px rgba(204,0,0,0.6);
            display: none;
        }
        
        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Annotation Panel */
        #annotationPanel {
            position: fixed;
            top: 120px;
            right: 30px;
            width: 240px;
            max-height: calc(100vh - 240px);
            background: rgba(20,20,20,0.98);
            border: 2px solid #f32411;
            border-radius: 20px;
            padding: 16px;
            z-index: 400;
            box-shadow: 0 8px 25px rgba(0,0,0,0.7), 0 0 20px rgba(204,0,0,0.3);
            backdrop-filter: blur(15px);
            overflow-y: auto;
            font-size: 0.85rem;
            opacity: 0;
            transform: translateX(120%);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #annotationPanel.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        #annotationPanel h3 {
            margin-bottom: 8px;
            color: #f32411;
            font-size: 1.2rem;
            text-align: center;
            text-shadow: 0 0 15px rgba(243,36,17,0.6);
            font-weight: 700;
        }
        
        .annotation-subtitle {
            text-align: center;
            color: #888;
            font-size: 0.75rem;
            font-style: italic;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(243,36,17,0.3);
        }
        
        .annotation-item {
            margin-bottom: 10px;
            padding: 12px;
            background: rgba(243,36,17,0.12);
            border-radius: 10px;
            border-left: 3px solid #f32411;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .annotation-item:hover {
            background: rgba(243,36,17,0.2);
            transform: translateX(6px) scale(1.01);
            box-shadow: 0 3px 12px rgba(243,36,17,0.4);
            border-left-color: #f32411;
        }
        
        .annotation-item.active {
            background: rgba(243,36,17,0.3);
            border-left-color: #f32411;
            box-shadow: 0 4px 15px rgba(243,36,17,0.5);
            transform: translateX(3px);
        }
        
        .annotation-header {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .annotation-number {
            width: 24px;
            height: 24px;
            background: #f32411;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
            font-size: 0.8rem;
            box-shadow: 0 2px 6px rgba(243,36,17,0.4);
            transition: transform 0.3s ease;
        }
        
        .annotation-item:hover .annotation-number {
            transform: scale(1.1);
        }
        
        .annotation-name {
            color: #fff;
            font-weight: 600;
            font-size: 0.95rem;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        
        .annotation-description {
            color: #ddd;
            line-height: 1.4;
            font-size: 0.75rem;
            margin-left: 34px;
            font-style: italic;
        }

        /* Welcome Overlay */
        #welcomeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 700;
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
        }
        
        #welcomeContent {
            background: rgba(20,20,20,0.95);
            border: 3px solid #cc0000;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
        }
        
        #welcomeContent h2 {
            margin-bottom: 20px;
            color: #cc0000;
            font-size: 2.2rem;
            text-shadow: 0 0 15px rgba(204,0,0,0.7);
        }
        
        #welcomeContent p {
            margin-bottom: 15px;
            line-height: 1.6;
            font-size: 1.1rem;
            color: #ddd;
        }
        
        .controls-hint {
            margin-top: 20px;
            padding: 15px;
            background: rgba(204,0,0,0.1);
            border-radius: 10px;
            border-left: 3px solid #cc0000;
            font-size: 1rem;
            color: #fff;
        }
        
        #welcomeStart {
            margin-top: 25px;
            font-size: 1.5rem;
            color: #cc0000;
            font-weight: bold;
            animation: blink 2s ease-in-out infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* ====== LIVERY PANEL STYLES ====== */
        #liveryPanel {
            position: fixed;
            top: 140px;
            left: 30px;
            width: 320px;
            max-height: calc(100vh - 200px);
            background: linear-gradient(145deg, rgba(20,20,20,0.98), rgba(30,15,15,0.95));
            border: 2px solid #cc0000;
            border-radius: 20px;
            padding: 20px;
            z-index: 400;
            box-shadow: 0 8px 25px rgba(0,0,0,0.7), 0 0 20px rgba(204,0,0,0.3);
            backdrop-filter: blur(15px);
            overflow-y: auto;
            opacity: 0;
            transform: translateX(-120%);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #liveryPanel.visible {
            opacity: 1;
            transform: translateX(0);
        }

        #liveryPanel h3 {
            margin-bottom: 8px;
            color: #cc0000;
            font-size: 1.2rem;
            text-align: center;
            text-shadow: 0 0 15px rgba(204,0,0,0.6);
            font-weight: 700;
        }

        .livery-subtitle {
            text-align: center;
            color: #888;
            font-size: 0.75rem;
            font-style: italic;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(204,0,0,0.3);
        }

        #liveryGrid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .livery-item {
            background: linear-gradient(135deg, rgba(204,0,0,0.08), rgba(255,0,0,0.04));
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            text-align: center;
        }

        .livery-item:hover {
            background: linear-gradient(135deg, rgba(204,0,0,0.15), rgba(255,0,0,0.08));
            transform: translateY(-2px) scale(1.02);
            border-color: rgba(204,0,0,0.5);
            box-shadow: 0 4px 15px rgba(204,0,0,0.3);
        }

        .livery-item.active {
            background: linear-gradient(135deg, rgba(204,0,0,0.25), rgba(255,0,0,0.15));
            border-color: #cc0000;
            box-shadow: 0 0 20px rgba(204,0,0,0.5);
            transform: scale(1.05);
        }

        .livery-preview {
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 40px;
        }

        .livery-colors {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
        }

        .livery-item:hover .color-swatch {
            transform: scale(1.1);
        }

        .original-gradient {
            background: linear-gradient(45deg, #cc0000, #0066cc, #000000, #ffd700);
            background-size: 400% 400%;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .livery-name {
            color: #fff;
            font-size: 0.8rem;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            line-height: 1.2;
        }

        @keyframes wind-flow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(0,255,0,0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(0,255,0,1), 0 0 40px rgba(0,200,255,0.5);
                transform: scale(1.05);
            }
        }

        /* Wind tunnel active indicator */
        #windTunnelBtn.active::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            border: 2px solid rgba(0,255,0,0.6);
            animation: wind-pulse 1.5s ease-in-out infinite;
        }

        @keyframes wind-pulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.2);
                opacity: 0.3;
            }
        }
        
        @media (max-width: 768px) {
            #homeScreen h1 { font-size: 2.8rem; }
            .feature-container { gap: 1.5rem; }
            .feature-circle { width: 150px; height: 150px; }
            .nav-arrow { width: 60px; height: 60px; font-size: 2rem; }
            #prev { left: 20px; }
            #next { right: 20px; }
            
            #topBar {
                padding: 0 15px;
                height: auto;
                min-height: 60px;
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
            }
            
            .iteration-info, .specs-info { 
                min-width: auto; 
                flex: auto;
            }
            .iteration-title { font-size: 1.4rem; }
            .spec-line { font-size: 0.8rem; }
            
            .iteration-selector-floating {
                bottom: 20px;
                right: 20px;
            }
            .iteration-dropdown {
                min-width: 200px;
                font-size: 0.9rem;
                padding: 10px 12px;
            }
            
            .center-controls {
                order: 3;
                width: 100%;
                justify-content: center;
                margin-top: 10px;
            }
            
            .ui-button {
                width: 40px;
                height: 40px;
                font-size: 1.2rem;
            }
            
            .control-label {
                font-size: 0.65rem;
                min-width: 60px;
            }
            
            #annotationPanel {
                position: fixed;
                bottom: 20px;
                right: 20px;
                left: 20px;
                top: auto;
                width: auto;
                max-height: 200px;
                transform: translateY(100%);
            }
            #annotationPanel.visible {
                transform: translateY(0);
            }
            
            /* Mobile subtitles - move to top center */
            #walkthroughSubtitles {
                top: 70px;
                right: 15px;
                left: 15px;
                max-width: none;
                min-width: auto;
                font-size: 0.85rem;
                padding: 12px 15px;
                text-align: center;
                transform: translateY(-20px);
            }
            #walkthroughSubtitles.visible {
                transform: translateY(0);
            }

            /* Mobile responsive for livery panel */
            #liveryPanel {
                position: fixed;
                bottom: 100px;
                left: 15px;
                right: 15px;
                top: auto;
                width: auto;
                max-height: 300px;
                transform: translateY(100%);
            }
            
            #liveryPanel.visible {
                transform: translateY(0);
            }
            
            #liveryGrid {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            
            .livery-item {
                padding: 8px;
            }
            
            .livery-name {
                font-size: 0.7rem;
            }
            
            .color-swatch {
                width: 16px;
                height: 16px;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(51,51,51,0.5);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb {
            background: #cc0000;
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #ff0000;
        }
    </style>
</head>
<body>
    <!-- Home Screen -->
    <div id="homeScreen">
        <h1>Aeros Racing ‚Äì Car Viewer</h1>
        <div class="feature-container">
            <div class="feature-circle">
                <span class="feature-icon">‚ÑπÔ∏è</span>
                <div>Car Annotations</div>
            </div>
            <div class="feature-circle">
                <span class="feature-icon">üéß</span>
                <div>Guided Tour</div>
            </div>
            <div class="feature-circle">
                <span class="feature-icon">üé®</span>
                <div>Custom Liveries</div>
            </div>
            <div class="feature-circle">
                <span class="feature-icon">üå™Ô∏è</span>
                <div>Wind Tunnel</div>
            </div>
        </div>
        <p id="tapText">TAP ANYWHERE TO START</p>
    </div>

    <!-- Main Canvas -->
    <canvas id="c"></canvas>

    <!-- Top UI Bar -->
    <div id="topBar">
        <div class="iteration-info">
            <div class="iteration-title" id="iterationTitle">ITERATION 1</div>
            <div class="iteration-subtitle" id="iterationSubtitle">Initial Design</div>
        </div>
        
        <div class="center-controls">
            <div class="control-group">
                <button id="auto" class="ui-button" title="Toggle Auto-Rotate">‚ü≥</button>
                <div class="control-label">Auto Rotate</div>
            </div>
            <div class="control-group">
                <button id="liveryBtn" class="ui-button" title="Change Livery">üé®</button>
                <div class="control-label">Change Livery</div>
            </div>
            <div class="control-group">
                <button id="windTunnelBtn" class="ui-button" title="Activate Wind Tunnel">üå™Ô∏è</button>
                <div class="control-label">Wind Tunnel</div>
            </div>
            <div class="control-group">
                <button id="resetBtn" class="ui-button" title="Return Home">üè†</button>
                <div class="control-label">Return Home</div>
            </div>
        </div>
        
        <div class="specs-info" id="specsInfo">
            <div class="spec-line">Weight: <span class="spec-highlight">52g</span></div>
            <div class="spec-line">Length: <span class="spec-highlight">210mm</span></div>
            <div class="spec-line">Drag Coeff: <span class="spec-highlight">0.32</span></div>
        </div>
    </div>

    <!-- Navigation Arrows -->
    <div id="prev" class="nav-arrow" title="Previous Iteration">‚óÑ</div>
    <div id="next" class="nav-arrow" title="Next Iteration">‚ñ∫</div>

    <!-- Iteration Selector -->
    <div id="iterationSelector" class="iteration-selector-floating">
        <select id="iterationDropdown" class="iteration-dropdown">
            <option value="0" selected>Iteration 1 - Initial Concept</option>
            <option value="1">Iteration 2 - Rearpod Detail</option>
            <option value="2">Iteration 3 - Symmetrical Enhancement</option>
            <option value="3">Iteration 4 - Diffuser Integration</option>
            <option value="4">AW-25 Final - Production Ready</option>
        </select>
    </div>

    <!-- Instructions Panel -->
    <div id="instructionsPanel">
        <h3>Controls</h3>
        <ul>
            <li><span class="control-key">Drag</span>Rotate View</li>
            <li><span class="control-key">Pinch</span>Zoom In/Out</li>
            <li><span class="control-key">2 Finger</span>Pan Around</li>
            <li><span class="control-key">‚óÑ ‚ñ∫</span>Switch Iteration</li>
            <li><span class="control-key">‚ü≥</span>Auto Rotate</li>
            <li><span class="control-key">üé®</span>Change Livery</li>
            <li><span class="control-key">üå™Ô∏è</span>Wind Tunnel</li>
            <li><span class="control-key">üéß</span>Guided Walkthrough</li>
        </ul>
    </div>

    <!-- Annotation Panel -->
    <div id="annotationPanel">
        <h3>Components</h3>
        <div class="annotation-subtitle">Click to view detailed sections</div>
        <div id="annotationContent">
            <!-- Annotations will be populated here -->
        </div>
    </div>

    <!-- Livery Panel -->
    <div id="liveryPanel">
        <h3>Car Liveries</h3>
        <div class="livery-subtitle">Choose your racing colors</div>
        <div id="liveryGrid">
            <!-- Liveries will be populated here -->
        </div>
    </div>

    <!-- Walkthrough Button - Detached -->
    <button id="walkthroughButton" title="Start Guided Walkthrough">GUIDED WALKTHROUGH</button>

    <!-- Walkthrough Subtitles -->
    <div id="walkthroughSubtitles"></div>

    <!-- Loading Spinner -->
    <div id="loader"></div>

    <!-- Welcome Overlay -->
    <div id="welcomeOverlay">
        <div id="welcomeContent">
            <h2>3D Iteration Viewer</h2>
            <p>Explore different car iterations with interactive 3D controls.</p>
            <div class="controls-hint">
                <strong>Navigation:</strong><br>
                ‚Ä¢ Use arrows to switch iterations<br>
                ‚Ä¢ Click components for detailed views<br>
                ‚Ä¢ Auto-rotate for hands-free viewing<br>
                ‚Ä¢ Change liveries and enable wind tunnel<br>
                ‚Ä¢ Take the guided tour on the final iteration
            </div>
            <div id="welcomeStart">CLICK TO CONTINUE</div>
        </div>
    </div>

    <!-- Three.js Script -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // Global state
        let appState = 'home';
        let currentModel = null;
        let currentIndex = 0; // Start on iteration 1 (index 0)
        let scene, camera, renderer, controls;
        let idleTimer = null;
        let walkthroughActive = false;
        let walkthroughAnimation = null;
        let speechTimeoutId = null;
        let walkthroughAudio = null;
        let walkthroughStartTime = null;
        
        // Wind tunnel state
        let windTunnel = null;
        let windTunnelActive = false;

        // Livery system state
        let currentLivery = 'aeros_red';
        let originalMaterials = new Map();
        
        // UI elements
        const ui = {
            home: document.getElementById('homeScreen'),
            welcome: document.getElementById('welcomeOverlay'),
            topBar: document.getElementById('topBar'),
            prev: document.getElementById('prev'),
            next: document.getElementById('next'),
            auto: document.getElementById('auto'),
            livery: document.getElementById('liveryBtn'),
            windTunnel: document.getElementById('windTunnelBtn'),
            walkthrough: document.getElementById('walkthroughButton'),
            subtitles: document.getElementById('walkthroughSubtitles'),
            reset: document.getElementById('resetBtn'),
            loader: document.getElementById('loader'),
            instructions: document.getElementById('instructionsPanel'),
            iterationTitle: document.getElementById('iterationTitle'),
            iterationSubtitle: document.getElementById('iterationSubtitle'),
            specsInfo: document.getElementById('specsInfo'),
            annotationPanel: document.getElementById('annotationPanel'),
            annotationContent: document.getElementById('annotationContent'),
            liveryPanel: document.getElementById('liveryPanel'),
            iterationDropdown: document.getElementById('iterationDropdown')
        };

        // Configuration
        const MODELS = [
            'iteration1.glb',
            'iteration2.glb',
            'iteration3.glb',
            'iteration4.glb',
            'AW-25.glb'
        ];

        const ITERATIONS = [
            { title: "ITERATION 1", subtitle: "Initial Concept", specs: { "Weight": "50g", "Length": "210mm", "Drag Coeff": "0.45" } },
            { title: "ITERATION 2", subtitle: "Rearpod Detail", specs: { "Weight": "50g", "Length": "210mm", "Drag Coeff": "0.38" } },
            { title: "ITERATION 3", subtitle: "Symmetrical Enhancement", specs: { "Weight": "50g", "Length": "210mm", "Drag Coeff": "0.35" } },
            { title: "ITERATION 4", subtitle: "Diffuser Integration", specs: { "Weight": "50g", "Length": "210mm", "Drag Coeff": "0.33" } },
            { title: "AW-25 FINAL", subtitle: "Production Ready", specs: { "Weight": "48g", "Length": "210mm", "Drag Coeff": "0.32" } }
        ];

        // Annotation system
        const ANNOTATIONS = [
            { id: 1, name: "Fendered Front Wing", description: "Directs flow around rather than over the front wheels and into their contact patch to reduce jetting while keeping a minimal philosophy." },
            { id: 2, name: "Sidepod Strake", description: "Generates corrective drag in yaw to keep the thrust vector of the CO2 canister aligned with the direction of travel." },
            { id: 3, name: "Sidepods", description: "Create minimal drag while housing the virtual cargo." },
            { id: 4, name: "Rearpods", description: "Effectively stunt the rear wheel wakes from growing while helping reduce the rear wake." },
            { id: 5, name: "Diffuser", description: "Working in conjunction with the lift generating front wing and sidepods creates an aerodynamic moment that counters that of the CO2 canister‚Äôs to keep the pitch of the racer level." },
            { id: 6, name: "Rear Wing", description: "With two profiles to efficiently adjust aerodynamic balance in CAD." }
        ];

        // Livery configurations
        const LIVERIES = {
            aeros_red: {
                name: "Aeros Racing Red",
                colors: {
                    chassis: 0xf32411,
                    wings: 0xf32411,
                    sidepods: 0xf32411,
                    cockpit: 0x333333,
                    wheels: 0x111111
                },
                materials: {
                    chassis: { metalness: 0.7, roughness: 0.2 },
                    wings: { metalness: 0.8, roughness: 0.1 },
                    sidepods: { metalness: 0.6, roughness: 0.3 }
                },
                background: 0x0a0a0a // Dark background
            },
            stealth_black: {
                name: "Stealth Black",
                colors: {
                    chassis: 0x1a1a1a,
                    wings: 0x000000,
                    sidepods: 0x2a2a2a,
                    cockpit: 0x0a0a0a,
                    wheels: 0x333333
                },
                materials: {
                    chassis: { metalness: 0.9, roughness: 0.1 },
                    wings: { metalness: 0.8, roughness: 0.05 },
                    sidepods: { metalness: 0.7, roughness: 0.2 }
                },
                background: 0xf0f0f0 // White background for contrast
            },
            electric_blue: {
                name: "Electric Blue",
                colors: {
                    chassis: 0x0066ff,
                    wings: 0x0044cc,
                    sidepods: 0x0088ff,
                    cockpit: 0x333333,
                    wheels: 0x222222
                },
                materials: {
                    chassis: { metalness: 0.6, roughness: 0.3 },
                    wings: { metalness: 0.7, roughness: 0.2 },
                    sidepods: { metalness: 0.5, roughness: 0.4 }
                },
                background: 0x001122 // Dark blue background
            },
            carbon_fiber: {
                name: "Carbon Fiber",
                colors: {
                    chassis: 0x2a2a2a,
                    wings: 0x1a1a1a,
                    sidepods: 0x333333,
                    cockpit: 0x0a0a0a,
                    wheels: 0x111111
                },
                materials: {
                    chassis: { metalness: 0.1, roughness: 0.8 },
                    wings: { metalness: 0.1, roughness: 0.7 },
                    sidepods: { metalness: 0.2, roughness: 0.6 }
                },
                background: 0x1a1a1a // Medium gray background
            },
            gold_edition: {
                name: "Gold Edition",
                colors: {
                    chassis: 0xffd700,
                    wings: 0xffb300,
                    sidepods: 0xffc400,
                    cockpit: 0x333333,
                    wheels: 0x444444
                },
                materials: {
                    chassis: { metalness: 0.9, roughness: 0.1 },
                    wings: { metalness: 0.95, roughness: 0.05 },
                    sidepods: { metalness: 0.8, roughness: 0.15 }
                },
                background: 0x1a1000 // Dark golden background
            }
        };

        // Walkthrough System - EXACT annotation positions, NO MOVEMENT
        const WALKTHROUGH_SCRIPT = [
            {
                camera: { position: [4, 6, 4], target: [0, 4, 1.6] },
                text: "Welcome to our championship winning Formula One car. After three months of intensive development, over forty unique designs, and extensive computational fluid dynamics testing, this is our final iteration that achieves the perfect balance between mass, drag, and friction."
            },
            {
                // FRONT WING - exact annotation position
                camera: { position: [0.03, 5.83, 5.28], target: [-0.11, 2.88, 1.24] },
                text: "Our body is designed to be as streamlined as possible, utilizing ultra-lightweight carbon fiber nylon for our halo and high-resolution ABS-like resin for our wing construction and wheel supports. At the front, fenders inspired by prototype race cars direct airflow around rather than over our front wheels."
            },
            {
                // RIGHT SIDEPOD - exact annotation position  
                camera: { position: [5.13, 5.57, 1.66], target: [-1.63, 4.08, 0.96] },
                text: "We disconnected our nose cone from the chassis to reduce obstruction to the flow going through our central channel. Moving along the side, these veins activate in yaw conditions to correct the alignment of our racer and keep the wake of our front wheels from going rogue."
            },
            {
                // LEFT SIDEPOD - exact annotation position
                camera: { position: [-4.83, 5.4, 1.65], target: [1.24, 3.84, 2.04] },
                text: "The sidepods house our cooling systems while directing airflow efficiently. Every surface has been optimized through computational fluid dynamics to ensure balanced airflow configuration across both sides of the vehicle."
            },
            {
                // REAR WING - exact annotation position
                camera: { position: [-0.04, 6.09, -2.39], target: [-0.13, 3.6, 1.11] },
                text: "At the back of our racer, pods behind our rear wheels effectively stunt their wakes from forming, while our rear wing creates optimal downforce balance. The rest of our design takes on a minimalist philosophy for maximum aerodynamic efficiency."
            },
            {
                // UNDERFLOOR - exact annotation position
                camera: { position: [0.17, -1.99, 2.25], target: [0.17, 1.87, 1.96] },
                text: "The underfloor utilizes ground effect aerodynamics for enhanced grip and stability. This final design achieves our perfect balance between mass, drag, and friction, ready to dominate any track. Thank you for taking our guided tour."
            }
        ];

        // Timing for each step in the audio file (in seconds) - Total audio: 1:47 (107 seconds)
        const WALKTHROUGH_TIMINGS = [
            { start: 0, duration: 18 },    // Step 1: 0-18s
            { start: 18, duration: 20 },   // Step 2: 18-38s  
            { start: 38, duration: 18 },   // Step 3: 38-56s
            { start: 56, duration: 16 },   // Step 4: 56-72s
            { start: 72, duration: 18 },   // Step 5: 72-90s
            { start: 90, duration: 17 }    // Step 6: 90-107s
        ];

        // ====== UTILITY FUNCTIONS ======
        // Clean up audio
        function cleanupAudio() {
            if (walkthroughAudio) {
                walkthroughAudio.pause();
                walkthroughAudio.currentTime = 0;
                walkthroughAudio = null;
            }
            walkthroughStartTime = null;
            if (speechTimeoutId) {
                clearTimeout(speechTimeoutId);
                speechTimeoutId = null;
            }
        }

        // Material disposal
        function disposeMaterial(material) {
            if (material.map) material.map.dispose();
            if (material.normalMap) material.normalMap.dispose();
            if (material.roughnessMap) material.roughnessMap.dispose();
            if (material.metalnessMap) material.metalnessMap.dispose();
            material.dispose();
        }

        // Model disposal
        function disposeModel(model) {
            model.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => disposeMaterial(mat));
                        } else {
                            disposeMaterial(child.material);
                        }
                    }
                }
            });
        }

        // ====== WIND TUNNEL SYSTEM ======
        class WindTunnel {
            constructor(scene, carModel) {
                this.scene = scene;
                this.carModel = carModel;
                this.particles = null;
                this.particleSystem = null;
                this.staticParticles = null; // Static particles that don't move
                this.staticParticleSystem = null;
                this.clock = new THREE.Clock();
                
                // ULTRA MASSIVE ENHANCEMENT: 100,000+ particle CFD
                this.particleCount = 40000; // Dynamic particles
                this.staticParticleCount = 60000; // MASSIVE static cloud
                this.flowSpeed = 1.0;
                this.flowWidth = 18;
                this.flowHeight = 16;
                this.flowLength = 40;
                this.particleSize = 0.045; // Smaller particles for massive density
                this.streamlineCount = 150; // Many more streamlines
                this.particlesPerStreamline = Math.floor(this.particleCount / this.streamlineCount);
                
                this.init();
                console.log('ULTRA MASSIVE CFD initialized with 100,000 particles');
            }
            
            init() {
                // Create particle geometry
                this.particles = new THREE.BufferGeometry();
                
                // Arrays for particle data
                const positions = new Float32Array(this.particleCount * 3);
                const velocities = new Float32Array(this.particleCount * 3);
                const colors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                const lifetimes = new Float32Array(this.particleCount);
                const streamlineIds = new Float32Array(this.particleCount);
                
                // Get precise car dimensions
                const carBox = new THREE.Box3().setFromObject(this.carModel);
                const carCenter = carBox.getCenter(new THREE.Vector3());
                const carSize = carBox.getSize(new THREE.Vector3());
                
                // ======= ENHANCED: COMPLETELY REDESIGNED PARTICLE DISTRIBUTION =======
                let particleIndex = 0;
                
                // 1. CREATE SPECIAL DENSE TOP SECTION WITH RED PARTICLES
                // ---------------------------------------------------------
                const topSectionParticles = Math.floor(this.particleCount * 0.35); // 35% of particles for top
                const topGridSize = Math.ceil(Math.sqrt(topSectionParticles / 2)); // Denser grid
                
                for (let p = 0; p < topSectionParticles; p++) {
                    if (particleIndex >= this.particleCount) break;
                    
                    const i3 = particleIndex * 3;
                    const rowTop = Math.floor(p / topGridSize);
                    const colTop = p % topGridSize;
                    
                    // Dense coverage directly above and around the top of the car
                    positions[i3] = carCenter.x + (colTop - topGridSize/2) * (carSize.x * 3.0 / topGridSize);
                    positions[i3 + 1] = carCenter.y + carSize.y * 0.8 + (rowTop / topGridSize) * carSize.y * 1.0;
                    positions[i3 + 2] = carCenter.z + (Math.random() - 0.5) * carSize.z * 2.0;
                    
                    // Slight velocity, mostly horizontal
                    velocities[i3] = (Math.random() - 0.5) * 0.3;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.2;
                    velocities[i3 + 2] = -this.flowSpeed * (0.8 + Math.random() * 0.4);
                    
                    // BRIGHT RED for top section particles
                    colors[i3] = 1.0; // Full red
                    colors[i3 + 1] = 0.1 + Math.random() * 0.3; // Slight green variation for visual interest
                    colors[i3 + 2] = 0.0; // No blue
                    
                    sizes[particleIndex] = this.particleSize * (1.0 + Math.random() * 0.8); // Slightly larger particles
                    lifetimes[particleIndex] = Math.random() * 20;
                    streamlineIds[particleIndex] = 8000 + p; // Special ID for top section
                    
                    particleIndex++;
                }
                
                // 2. MAIN LAYER SYSTEM: MULTIPLE HORIZONTAL LAYERS
                // ---------------------------------------------------------
                // Layer definition - more layers, better spacing
                const layers = [
                    { heightOffset: -carSize.y * 0.1, density: 1.8, particles: Math.floor(this.particleCount * 0.15) }, // Ground layer
                    { heightOffset: carSize.y * 0.2, density: 1.6, particles: Math.floor(this.particleCount * 0.12) },  // Lower layer
                    { heightOffset: carSize.y * 0.5, density: 1.4, particles: Math.floor(this.particleCount * 0.10) },  // Mid layer
                    { heightOffset: carSize.y * 0.9, density: 1.2, particles: Math.floor(this.particleCount * 0.08) },  // Upper layer
                ];
                
                // Create each layer
                layers.forEach((layer, layerIndex) => {
                    const layerStreamlines = Math.floor(this.streamlineCount * layer.density / layers.length);
                    const gridSize = Math.ceil(Math.sqrt(layerStreamlines));
                    const particlesPerLine = Math.floor(layer.particles / layerStreamlines);
                    
                    for (let s = 0; s < layerStreamlines; s++) {
                        if (particleIndex >= this.particleCount) break;
                        
                        const row = Math.floor(s / gridSize);
                        const col = s % gridSize;
                        
                        // Create a straight streamline for this position
                        const targetX = carCenter.x + (col - gridSize/2) * (carSize.x * 2.8 / gridSize);
                        const targetY = carCenter.y + layer.heightOffset;
                        
                        for (let p = 0; p < particlesPerLine; p++) {
                            if (particleIndex >= this.particleCount) break;
                            
                            const i3 = particleIndex * 3;
                            const progress = p / particlesPerLine;
                            
                            // Calculate position along streamline
                            const startZ = 25;  // Further upstream
                            const endZ = -25;   // Further downstream
                            const currentZ = startZ - progress * (startZ - endZ);
                            
                            // Minimal randomness for tight alignment
                            positions[i3] = targetX + (Math.random() - 0.5) * 0.01;
                            positions[i3 + 1] = targetY + (Math.random() - 0.5) * 0.01;
                            positions[i3 + 2] = currentZ;
                            
                            // Base velocity direction
                            velocities[i3] = (carCenter.x - positions[i3]) * 0.015;
                            velocities[i3 + 1] = (carCenter.y - positions[i3 + 1]) * 0.01;
                            velocities[i3 + 2] = -this.flowSpeed * (0.9 + Math.random() * 0.2);
                            
                            // Height-based color coding
                            const relativeHeight = (positions[i3 + 1] - carBox.min.y) / carSize.y;
                            
                            if (relativeHeight < 0.1) {
                                // Very low - dark blue (ground effect)
                                colors[i3] = 0.0; colors[i3 + 1] = 0.1; colors[i3 + 2] = 0.9;
                            } else if (relativeHeight < 0.3) {
                                // Low - blue to cyan
                                colors[i3] = 0.0; colors[i3 + 1] = 0.5; colors[i3 + 2] = 1.0;
                            } else if (relativeHeight < 0.6) {
                                // Mid - cyan to green
                                colors[i3] = 0.0; colors[i3 + 1] = 0.9; colors[i3 + 2] = 0.5;
                            } else if (relativeHeight < 0.9) {
                                // High - green to yellow
                                colors[i3] = 0.7; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.1;
                            } else {
                                // Very high - yellow to orange
                                colors[i3] = 1.0; colors[i3 + 1] = 0.6; colors[i3 + 2] = 0.0;
                            }
                            
                            sizes[particleIndex] = this.particleSize * (0.8 + Math.random() * 0.4);
                            lifetimes[particleIndex] = Math.random() * 30;
                            streamlineIds[particleIndex] = s + layerIndex * 1000; // Unique ID per layer
                            
                            particleIndex++;
                        }
                    }
                });
                
                // 3. FILL REMAINING PARTICLES WITH HIGH-DENSITY FOCUS AREAS
                // ---------------------------------------------------------
                const remainingParticles = this.particleCount - particleIndex;
                
                // Create focused clusters around key areas of the car
                const focusAreas = [
                    { // Front wing area
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 0.2, carCenter.z + carSize.z * 0.4),
                        size: new THREE.Vector3(carSize.x * 0.8, carSize.y * 0.4, carSize.z * 0.3),
                        color: { r: 0.0, g: 0.6, b: 1.0 }, // Blue
                        count: Math.floor(remainingParticles * 0.25)
                    },
                    { // Rear wing area
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 0.6, carCenter.z - carSize.z * 0.4),
                        size: new THREE.Vector3(carSize.x * 0.7, carSize.y * 0.5, carSize.z * 0.3),
                        color: { r: 1.0, g: 0.3, b: 0.0 }, // Red-orange
                        count: Math.floor(remainingParticles * 0.25)
                    },
                    { // Wake area
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 0.4, carCenter.z - carSize.z * 1.2),
                        size: new THREE.Vector3(carSize.x * 1.0, carSize.y * 0.8, carSize.z * 0.8),
                        color: { r: 0.8, g: 0.2, b: 0.8 }, // Purple
                        count: Math.floor(remainingParticles * 0.25)
                    },
                    { // Top area (additional red)
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 1.2, carCenter.z),
                        size: new THREE.Vector3(carSize.x * 1.2, carSize.y * 0.6, carSize.z * 0.8),
                        color: { r: 1.0, g: 0.1, b: 0.0 }, // Pure red
                        count: Math.floor(remainingParticles * 0.25)
                    }
                ];
                
                // Distribute remaining particles in focus areas
                for (const area of focusAreas) {
                    for (let p = 0; p < area.count; p++) {
                        if (particleIndex >= this.particleCount) break;
                        
                        const i3 = particleIndex * 3;
                        
                        // Random position within focus area
                        positions[i3] = area.center.x + (Math.random() - 0.5) * area.size.x;
                        positions[i3 + 1] = area.center.y + (Math.random() - 0.5) * area.size.y;
                        positions[i3 + 2] = area.center.z + (Math.random() - 0.5) * area.size.z;
                        
                        // Velocity based on position relative to car
                        velocities[i3] = (Math.random() - 0.5) * 0.2;
                        velocities[i3 + 1] = (Math.random() - 0.5) * 0.2;
                        velocities[i3 + 2] = -this.flowSpeed * (0.5 + Math.random() * 0.5);
                        
                        // Use focus area color with slight variation
                        colors[i3] = area.color.r * (0.9 + Math.random() * 0.2);
                        colors[i3 + 1] = area.color.g * (0.9 + Math.random() * 0.2);
                        colors[i3 + 2] = area.color.b * (0.9 + Math.random() * 0.2);
                        
                        // Slightly larger particles for focus areas
                        sizes[particleIndex] = this.particleSize * (1.2 + Math.random() * 0.8);
                        lifetimes[particleIndex] = Math.random() * 25;
                        streamlineIds[particleIndex] = 9000 + p; // Special ID for focus areas
                        
                        particleIndex++;
                    }
                }
                
                // Create STATIC particles that don't move (always visible)
                this.initializeStaticParticles(carCenter, carSize);
                
                // Set all attributes
                this.particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                this.particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                this.particles.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                this.particles.setAttribute('streamlineId', new THREE.BufferAttribute(streamlineIds, 1));
                
                // Enhanced particle material for ultra-vivid colors
                const particleMaterial = new THREE.PointsMaterial({
                    size: this.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.95, // Higher opacity for vivid colors
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    alphaTest: 0.0001
                });
                
                this.particleSystem = new THREE.Points(this.particles, particleMaterial);
                this.scene.add(this.particleSystem);
                
                console.log('ULTRA ENHANCED CFD: 20,000 dynamic + 5,000 static particles, 35% dedicated to top section');
            }
            
            // Create static particles that don't move - ULTRA DENSE CLOUD
            initializeStaticParticles(carCenter, carSize) {
                console.log('Creating ultra-dense static particle cloud with 60,000 particles');
                
                // Create static particle geometry
                this.staticParticles = new THREE.BufferGeometry();
                
                // Arrays for static particle data
                const positions = new Float32Array(this.staticParticleCount * 3);
                const colors = new Float32Array(this.staticParticleCount * 3);
                const sizes = new Float32Array(this.staticParticleCount);
                
                // Define zones for static particles with massively increased counts
                const zones = [
                    { 
                        // Top red zone (40% of static particles)
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 1.2, carCenter.z),
                        size: new THREE.Vector3(carSize.x * 3.0, carSize.y * 1.2, carSize.z * 2.5),
                        color: { r: 1.0, g: 0.1, b: 0.0 }, // Pure red
                        count: Math.floor(this.staticParticleCount * 0.40),
                        sizeMultiplier: 1.2
                    },
                    { 
                        // Around car body (30% of static particles)
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 0.4, carCenter.z),
                        size: new THREE.Vector3(carSize.x * 1.5, carSize.y * 0.8, carSize.z * 1.2),
                        color: { r: 1.0, g: 0.7, b: 0.0 }, // Yellow-orange
                        count: Math.floor(this.staticParticleCount * 0.30),
                        sizeMultiplier: 1.0
                    },
                    { 
                        // Sides of car (15% of static particles)
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 0.5, carCenter.z),
                        size: new THREE.Vector3(carSize.x * 2.5, carSize.y * 0.4, carSize.z * 1.0),
                        color: { r: 0.0, g: 0.8, b: 1.0 }, // Cyan
                        count: Math.floor(this.staticParticleCount * 0.15),
                        sizeMultiplier: 0.9
                    },
                    { 
                        // Wake zone (15% of static particles)
                        center: new THREE.Vector3(carCenter.x, carCenter.y + carSize.y * 0.5, carCenter.z - carSize.z * 1.5),
                        size: new THREE.Vector3(carSize.x * 2.0, carSize.y * 1.2, carSize.z * 2.0),
                        color: { r: 0.8, g: 0.2, b: 0.9 }, // Purple
                        count: Math.floor(this.staticParticleCount * 0.15),
                        sizeMultiplier: 1.1
                    }
                ];
                
                let particleIndex = 0;
                
                // Create ultra-dense cloud using optimization techniques
                for (const zone of zones) {
                    // Create a batch of particles at once for each zone
                    for (let p = 0; p < zone.count; p++) {
                        if (particleIndex >= this.staticParticleCount) break;
                        
                        const i3 = particleIndex * 3;
                        
                        // Use Gaussian-like distribution for natural clustering
                        // Add multiple random values for better Gaussian approximation
                        const rx = ((Math.random() + Math.random() + Math.random() + Math.random()) / 2 - 1);
                        const ry = ((Math.random() + Math.random() + Math.random() + Math.random()) / 2 - 1);
                        const rz = ((Math.random() + Math.random() + Math.random() + Math.random()) / 2 - 1);
                        
                        // Position within zone with exponential falloff from center
                        positions[i3] = zone.center.x + rx * zone.size.x;
                        positions[i3 + 1] = zone.center.y + ry * zone.size.y;
                        positions[i3 + 2] = zone.center.z + rz * zone.size.z;
                        
                        // Use zone color with slight variation for visual interest
                        const colorVariation = 0.15;
                        colors[i3] = zone.color.r * (1 - colorVariation/2 + Math.random() * colorVariation);
                        colors[i3 + 1] = zone.color.g * (1 - colorVariation/2 + Math.random() * colorVariation);
                        colors[i3 + 2] = zone.color.b * (1 - colorVariation/2 + Math.random() * colorVariation);
                        
                        // Vary sizes for natural look - smaller particles towards edges
                        const distanceFromCenter = Math.sqrt(rx*rx + ry*ry + rz*rz);
                        const sizeVariation = Math.max(0.6, 1 - distanceFromCenter * 0.5); // Smaller towards edges
                        sizes[particleIndex] = this.particleSize * zone.sizeMultiplier * sizeVariation * (0.8 + Math.random() * 0.4);
                        
                        particleIndex++;
                    }
                }
                
                this.staticParticles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.staticParticles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.staticParticles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Create material with higher opacity for static particles
                const staticMaterial = new THREE.PointsMaterial({
                    size: this.particleSize * 1.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.75, // Higher opacity for more visible cloud
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    alphaTest: 0.0001
                });
                
                this.staticParticleSystem = new THREE.Points(this.staticParticles, staticMaterial);
                this.scene.add(this.staticParticleSystem);
                
                console.log(`Created ${particleIndex} static particles in ultra-dense cloud configuration`);
            }
            
            update() {
                if (!this.particles || !this.carModel) return;
                
                const delta = this.clock.getDelta();
                const positions = this.particles.attributes.position.array;
                const velocities = this.particles.attributes.velocity.array;
                const colors = this.particles.attributes.color.array;
                const lifetimes = this.particles.attributes.lifetime.array;
                const streamlineIds = this.particles.attributes.streamlineId.array;
                
                // Get car geometry for flow simulation
                const carBox = new THREE.Box3().setFromObject(this.carModel);
                const carCenter = carBox.getCenter(new THREE.Vector3());
                const carSize = carBox.getSize(new THREE.Vector3());
                
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Current particle position
                    let x = positions[i3];
                    let y = positions[i3 + 1];
                    let z = positions[i3 + 2];
                    
                    // Update lifetime
                    lifetimes[i] += delta;
                    
                    // Calculate distance to car
                    const distanceToCarCenter = Math.sqrt(
                        Math.pow(x - carCenter.x, 2) +
                        Math.pow(y - carCenter.y, 2) +
                        Math.pow(z - carCenter.z, 2)
                    );
                    
                    // Multi-zone CFD simulation with enhanced effects
                    let deflectionX = 0;
                    let deflectionY = 0;
                    let speedMultiplier = 1;
                    let colorIntensity = 1;
                    
                    // ENHANCED: Far-field influence zone with color preservation
                    const farFieldRadius = Math.max(carSize.x, carSize.y, carSize.z) * 4.0;
                    if (distanceToCarCenter < farFieldRadius && z > carCenter.z - carSize.z * 0.5) {
                        const farInfluence = Math.max(0, 1 - distanceToCarCenter / farFieldRadius) * 0.6;
                        deflectionX += (x - carCenter.x) * farInfluence * 0.5;
                        deflectionY += Math.max(0, (y - carCenter.y + carSize.y * 0.3)) * farInfluence * 0.4;
                        
                        // Start increasing color intensity as we approach car
                        colorIntensity = 1 + farInfluence * 0.5;
                    }
                    
                    // ENHANCED: Near-field high velocity zone (BRIGHTEN colors here!)
                    const nearFieldRadius = Math.max(carSize.x, carSize.y, carSize.z) * 2.2;
                    if (distanceToCarCenter < nearFieldRadius) {
                        const nearInfluence = Math.max(0, 1 - distanceToCarCenter / nearFieldRadius);
                        
                        // Strong deflection for streamline effect
                        deflectionX += (x - carCenter.x) * nearInfluence * 3.0;
                        deflectionY += Math.max(0.5, (y - carCenter.y + carSize.y * 0.5)) * nearInfluence * 2.5;
                        
                        // Significant speed increase (Bernoulli principle)
                        speedMultiplier = 1 + nearInfluence * 2.5;
                        
                        // FIXED: INTENSIFY colors near car, don't fade them!
                        colorIntensity = 1 + nearInfluence * 1.5; // Make colors BRIGHTER near car
                        
                        // Enhanced dynamic color based on velocity with NO FADING
                        const velocityMagnitude = speedMultiplier;
                        const intensity = colorIntensity;
                        
                        if (velocityMagnitude > 2.8) {
                            // Very high speed - BRIGHT red/orange (top section)
                            colors[i3] = 1.0 * intensity;
                            colors[i3 + 1] = 0.1 * intensity;
                            colors[i3 + 2] = 0.0;
                        } else if (velocityMagnitude > 2.3) {
                            // High speed - orange/red
                            colors[i3] = 1.0 * intensity;
                            colors[i3 + 1] = 0.4 * intensity;
                            colors[i3 + 2] = 0.0;
                        } else if (velocityMagnitude > 1.8) {
                            // Medium-high speed - yellow/orange
                            colors[i3] = 1.0 * intensity;
                            colors[i3 + 1] = 0.8 * intensity;
                            colors[i3 + 2] = 0.1 * intensity;
                        } else if (velocityMagnitude > 1.4) {
                            // Medium speed - green/yellow
                            colors[i3] = 0.7 * intensity;
                            colors[i3 + 1] = 1.0 * intensity;
                            colors[i3 + 2] = 0.3 * intensity;
                        } else if (velocityMagnitude > 1.1) {
                            // Lower medium speed - cyan/green
                            colors[i3] = 0.2 * intensity;
                            colors[i3 + 1] = 0.9 * intensity;
                            colors[i3 + 2] = 0.7 * intensity;
                        } else {
                            // Lower speed - blue/cyan
                            colors[i3] = 0.0;
                            colors[i3 + 1] = 0.6 * intensity;
                            colors[i3 + 2] = 1.0 * intensity;
                        }
                    }
                    
                    // ENHANCED: Wake and turbulence zone with vivid colors
                    if (z < carCenter.z - carSize.z * 0.4 && distanceToCarCenter < nearFieldRadius * 3.0) {
                        const wakeInfluence = Math.max(0, 1 - distanceToCarCenter / (nearFieldRadius * 3.0));
                        
                        // Controlled turbulence
                        deflectionX += Math.sin(lifetimes[i] * 7 + streamlineIds[i]) * wakeInfluence * 1.0;
                        deflectionY += Math.cos(lifetimes[i] * 5 + streamlineIds[i] * 1.8) * wakeInfluence * 0.8;
                        
                        // Reduced speed in wake
                        speedMultiplier *= (1 - wakeInfluence * 0.7);
                        
                        // ENHANCED: Wake colors - bright purple/magenta (low pressure, high visibility)
                        const wakeIntensity = 1 + wakeInfluence * 0.8;
                        colors[i3] = 0.9 * wakeIntensity;
                        colors[i3 + 1] = 0.2 * wakeIntensity;
                        colors[i3 + 2] = 0.9 * wakeIntensity;
                    }
                    
                    // ENHANCED: Above car zone - maintain bright colors
                    if (y > carCenter.y + carSize.y * 0.5 && 
                        Math.abs(x - carCenter.x) < carSize.x * 1.5 && 
                        z > carCenter.z - carSize.z && z < carCenter.z + carSize.z) {
                        
                        const aboveInfluence = Math.max(0, 1 - Math.abs(y - carCenter.y - carSize.y * 0.5) / carSize.y);
                        speedMultiplier = Math.max(speedMultiplier, 1 + aboveInfluence * 1.8);
                        
                        // BRIGHT colors above car (red zone as requested)
                        const aboveIntensity = 1 + aboveInfluence * 1.2;
                        colors[i3] = 1.0 * aboveIntensity;
                        colors[i3 + 1] = 0.3 * aboveIntensity;
                        colors[i3 + 2] = 0.0;
                    }
                    
                    // Apply smooth changes
                    velocities[i3] += deflectionX * delta * 6;
                    velocities[i3 + 1] += deflectionY * delta * 6;
                    velocities[i3 + 2] *= speedMultiplier;
                    
                    // Damping for smooth flow
                    velocities[i3] *= 0.97;
                    velocities[i3 + 1] *= 0.97;
                    
                    // Update position
                    positions[i3] += velocities[i3] * delta;
                    positions[i3 + 1] += velocities[i3 + 1] * delta;
                    positions[i3 + 2] += velocities[i3 + 2] * delta;
                    
                    // ENHANCED: Reset particles with better car targeting and layering
                    if (z < -this.flowLength || 
                        Math.abs(x) > this.flowWidth || 
                        y > this.flowHeight * 1.8 || y < -4 ||
                        lifetimes[i] > 35) {
                        
                        // Determine which layer this particle belongs to
                        const streamlineId = streamlineIds[i];
                        const isExtraParticle = streamlineId === 9999;
                        
                        if (isExtraParticle) {
                            // Reset extra particles randomly around car
                            positions[i3] = carCenter.x + (Math.random() - 0.5) * carSize.x * 2.0;
                            positions[i3 + 1] = carCenter.y + (Math.random() - 0.5) * carSize.y * 2.0;
                            positions[i3 + 2] = 22 + Math.random() * 3;
                            
                            velocities[i3] = (Math.random() - 0.5) * 0.1;
                            velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
                            velocities[i3 + 2] = -this.flowSpeed;
                            
                            colors[i3] = Math.random() * 0.8;
                            colors[i3 + 1] = Math.random() * 0.8 + 0.2;
                            colors[i3 + 2] = Math.random() * 0.6 + 0.4;
                        } else {
                            // Reset layer-based particles to maintain alignment
                            const layerIndex = Math.floor(streamlineId / 1000);
                            const layerStreamlineId = streamlineId % 1000;
                            
                            const layers = [
                                { heightOffset: -carSize.y * 0.1, density: 1.5 },
                                { heightOffset: carSize.y * 0.2, density: 1.3 },
                                { heightOffset: carSize.y * 0.5, density: 1.2 },
                                { heightOffset: carSize.y * 0.8, density: 1.0 },
                                { heightOffset: carSize.y * 1.1, density: 0.8 }
                            ];
                            
                            const layer = layers[Math.min(layerIndex, layers.length - 1)];
                            const layerStreamlines = Math.floor(this.streamlineCount * layer.density / 5);
                            const gridSize = Math.ceil(Math.sqrt(layerStreamlines));
                            
                            if (layerStreamlineId < layerStreamlines) {
                                const row = Math.floor(layerStreamlineId / gridSize);
                                const col = layerStreamlineId % gridSize;
                                
                                const targetX = carCenter.x + (col - gridSize/2) * (carSize.x * 2.2 / gridSize);
                                const targetY = carCenter.y + layer.heightOffset;
                                
                                positions[i3] = targetX + (Math.random() - 0.5) * 0.02;
                                positions[i3 + 1] = targetY + (Math.random() - 0.5) * 0.02;
                                positions[i3 + 2] = 22 + Math.random() * 2;
                                
                                velocities[i3] = (carCenter.x - positions[i3]) * 0.02;
                                velocities[i3 + 1] = (carCenter.y - positions[i3 + 1]) * 0.015;
                                velocities[i3 + 2] = -this.flowSpeed * (0.92 + Math.random() * 0.16);
                                
                                // Reset to layer-appropriate color
                                const relativeHeight = (positions[i3 + 1] - carBox.min.y) / carSize.y;
                                if (relativeHeight < 0.1) {
                                    colors[i3] = 0.0; colors[i3 + 1] = 0.1; colors[i3 + 2] = 0.8;
                                } else if (relativeHeight < 0.3) {
                                    colors[i3] = 0.0; colors[i3 + 1] = 0.4; colors[i3 + 2] = 1.0;
                                } else if (relativeHeight < 0.6) {
                                    colors[i3] = 0.0; colors[i3 + 1] = 0.8; colors[i3 + 2] = 0.6;
                                } else if (relativeHeight < 0.9) {
                                    colors[i3] = 0.6; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.2;
                                } else {
                                    colors[i3] = 1.0; colors[i3 + 1] = 0.7; colors[i3 + 2] = 0.0;
                                }
                            }
                        }
                        
                        lifetimes[i] = 0;
                    }
                }
                
                // Mark all attributes as needing update
                this.particles.attributes.position.needsUpdate = true;
                this.particles.attributes.velocity.needsUpdate = true;
                this.particles.attributes.color.needsUpdate = true;
                this.particles.attributes.lifetime.needsUpdate = true;
            }
            
            setFlowSpeed(speed) {
                this.flowSpeed = speed;
            }
            
            // NEW: Allow changing the camera to a better CFD-viewing position
            setupOptimalCFDView(camera, controls) {
                // Position camera for excellent CFD visualization
                camera.position.set(9, 8, 5);
                controls.target.set(0, 2, 0);
                controls.update();
                
                console.log('Camera positioned for optimal CFD viewing');
            }
            
            destroy() {
                if (this.particleSystem) {
                    this.scene.remove(this.particleSystem);
                    this.particles.dispose();
                    this.particleSystem.material.dispose();
                    this.particleSystem = null;
                    this.particles = null;
                }
                
                if (this.staticParticleSystem) {
                    this.scene.remove(this.staticParticleSystem);
                    this.staticParticles.dispose();
                    this.staticParticleSystem.material.dispose();
                    this.staticParticleSystem = null;
                    this.staticParticles = null;
                }
                
                console.log('CFD simulation destroyed');
            }
        }

        // Wind tunnel control functions
        function toggleWindTunnel() {
            if (!currentModel) return;
            
            windTunnelActive = !windTunnelActive;
            
            if (windTunnelActive) {
                // PERFORMANCE WARNING - Display loader during initialization
                ui.loader.style.display = 'block';
                
                // Create wind tunnel after slight delay to allow UI update
                setTimeout(() => {
                    console.log('Initializing 100,000 particle CFD system...');
                    windTunnel = new WindTunnel(scene, currentModel);
                    ui.windTunnel.classList.add('active');
                    ui.windTunnel.title = 'Deactivate Wind Tunnel';
                    
                    // Stop auto-rotate for better CFD viewing
                    controls.autoRotate = false;
                    ui.auto.classList.remove('active');
                    
                    // Set optimal CFD viewing angle
                    windTunnel.setupOptimalCFDView(camera, controls);
                    
                    // Hide loader when done
                    ui.loader.style.display = 'none';
                    
                    console.log('ULTRA MASSIVE CFD Wind tunnel activated with 100,000 particles');
                }, 100);
            } else {
                // Destroy wind tunnel
                if (windTunnel) {
                    windTunnel.destroy();
                    windTunnel = null;
                }
                ui.windTunnel.classList.remove('active');
                ui.windTunnel.title = 'Activate Wind Tunnel';
                
                // Return to auto-rotate
                controls.autoRotate = true;
                ui.auto.classList.add('active');
                setCenteredAutoRotatePosition();
                
                console.log('Wind tunnel deactivated');
            }
            
            resetIdleTimer();
        }

        // ====== LIVERY SYSTEM ======
        // Material mapping - adjust these based on your actual model structure
        function getPartType(object) {
            const name = object.name.toLowerCase();
            
            // Common car part naming conventions
            if (name.includes('wing') || name.includes('spoiler')) return 'wings';
            if (name.includes('sidepod') || name.includes('side')) return 'sidepods';
            if (name.includes('cockpit') || name.includes('driver') || name.includes('seat')) return 'cockpit';
            if (name.includes('wheel') || name.includes('tire') || name.includes('rim')) return 'wheels';
            
            // Default to chassis for main body parts
            return 'chassis';
        }

        // Store original materials when model loads
        function storeOriginalMaterials(model) {
            originalMaterials.clear(); // Clear previous materials
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, {
                        material: child.material.clone(),
                        color: child.material.color ? child.material.color.clone() : null
                    });
                }
            });
        }

        // Apply livery to model
        function applyLivery(liveryKey) {
            if (!currentModel || !LIVERIES[liveryKey]) return;
            
            const livery = LIVERIES[liveryKey];
            
            currentModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    const partType = getPartType(child);
                    const colorHex = livery.colors[partType] || livery.colors.chassis;
                    const materialProps = livery.materials[partType] || livery.materials.chassis || {};
                    
                    // Apply color
                    if (child.material.color) {
                        child.material.color.setHex(colorHex);
                    }
                    
                    // Apply material properties
                    if (materialProps.metalness !== undefined) {
                        child.material.metalness = materialProps.metalness;
                    }
                    if (materialProps.roughness !== undefined) {
                        child.material.roughness = materialProps.roughness;
                    }
                    
                    child.material.needsUpdate = true;
                }
            });
            
            // Update background color for contrast
            if (scene && livery.background !== undefined) {
                scene.background = new THREE.Color(livery.background);
                console.log(`Updated background color for ${livery.name}`);
            }
            
            currentLivery = liveryKey;
            updateLiveryUI();
            console.log(`Applied livery: ${livery.name}`);
        }

        // Restore original materials
        function restoreOriginalMaterials() {
            if (!currentModel) return;
            
            currentModel.traverse((child) => {
                if (child.isMesh && originalMaterials.has(child.uuid)) {
                    const original = originalMaterials.get(child.uuid);
                    
                    if (original.color && child.material.color) {
                        child.material.color.copy(original.color);
                    }
                    
                    // Restore original material properties
                    if (original.material.metalness !== undefined) {
                        child.material.metalness = original.material.metalness;
                    }
                    if (original.material.roughness !== undefined) {
                        child.material.roughness = original.material.roughness;
                    }
                    
                    child.material.needsUpdate = true;
                }
            });
            
            // Restore original background color
            if (scene) {
                scene.background = new THREE.Color(0x0a0a0a);
                console.log('Restored original background color');
            }
            
            console.log('Restored original materials');
        }

        // Update UI to reflect current livery
        function updateLiveryUI() {
            const liveryItems = document.querySelectorAll('.livery-item');
            liveryItems.forEach(item => {
                item.classList.toggle('active', item.dataset.livery === currentLivery);
            });
        }

        // Create livery selection UI
        function createLiveryPanel() {
            // Create livery grid HTML
            const liveryGridHTML = `
                ${Object.entries(LIVERIES).map(([key, livery]) => `
                    <div class="livery-item ${key === currentLivery ? 'active' : ''}" data-livery="${key}">
                        <div class="livery-preview">
                            <div class="livery-colors">
                                <div class="color-swatch" style="background-color: #${livery.colors.chassis.toString(16).padStart(6, '0')}"></div>
                                <div class="color-swatch" style="background-color: #${livery.colors.wings.toString(16).padStart(6, '0')}"></div>
                                <div class="color-swatch" style="background-color: #${livery.colors.sidepods.toString(16).padStart(6, '0')}"></div>
                            </div>
                        </div>
                        <div class="livery-name">${livery.name}</div>
                    </div>
                `).join('')}
                <div class="livery-item" data-livery="original">
                    <div class="livery-preview">
                        <div class="livery-colors">
                            <div class="color-swatch original-gradient"></div>
                        </div>
                    </div>
                    <div class="livery-name">Original</div>
                </div>
            `;
            
            ui.liveryPanel.querySelector('#liveryGrid').innerHTML = liveryGridHTML;
            
            // Add event listeners
            ui.liveryPanel.querySelector('#liveryGrid').addEventListener('click', (e) => {
                const liveryItem = e.target.closest('.livery-item');
                if (liveryItem) {
                    const liveryKey = liveryItem.dataset.livery;
                    
                    if (liveryKey === 'original') {
                        restoreOriginalMaterials();
                        currentLivery = 'original';
                    } else {
                        applyLivery(liveryKey);
                    }
                    
                    updateLiveryUI();
                    resetIdleTimer();
                }
            });
        }

        // Toggle livery panel visibility
        function toggleLiveryPanel() {
            const isVisible = ui.liveryPanel.classList.contains('visible');
            ui.liveryPanel.classList.toggle('visible');
            
            // Hide instructions when livery panel is open, show when closed
            if (!isVisible) {
                // Livery panel is opening - hide instructions
                ui.instructions.style.display = 'none';
            } else {
                // Livery panel is closing - show instructions
                ui.instructions.style.display = 'block';
            }
        }

        // Hide livery panel
        function hideLiveryPanel() {
            ui.liveryPanel.classList.remove('visible');
            // Show instructions when livery panel is hidden
            ui.instructions.style.display = 'block';
        }

        // ====== ANNOTATION SYSTEM ======
        function createAnnotations() {
            if (!ui.annotationPanel || !ui.annotationContent) return;
            
            hideAnnotations();
            ui.annotationContent.innerHTML = '';
            
            ANNOTATIONS.forEach((annotation) => {
                const annotationItem = document.createElement('div');
                annotationItem.className = 'annotation-item';
                
                annotationItem.innerHTML = `
                    <div class="annotation-header">
                        <div class="annotation-number">${annotation.id}</div>
                        <div class="annotation-name">${annotation.name}</div>
                    </div>
                    <div class="annotation-description">
                        ${annotation.description}
                    </div>
                `;
                
                annotationItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    focusOnCarPart(annotation);
                    
                    // Clear other active states
                    ui.annotationContent.querySelectorAll('.annotation-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    annotationItem.classList.add('active');
                    resetIdleTimer();
                });
                
                ui.annotationContent.appendChild(annotationItem);
            });
            
            // Show annotations after delay
            setTimeout(() => {
                showAnnotations();
            }, 500);
        }

        function focusOnCarPart(annotation) {
            if (!currentModel) return;
            
            console.log(`Focusing on ${annotation.name}...`);
            
            // Disable auto-rotate first
            controls.autoRotate = false;
            ui.auto.classList.remove('active');
            
            // Camera positions for each annotation (using exact walkthrough positions)
            const cameraPositions = {
                1: { // Front Wing
                    position: [0.03, 5.83, 5.28],
                    target: [-0.11, 2.88, 1.24]
                },
                2: { // Right Sidepod
                    position: [5.13, 5.57, 1.66],
                    target: [-1.63, 4.08, 0.96]
                },
                3: { // Cockpit
                    position: [-0.03, 5.92, 3.11],
                    target: [0, 1.6, 0]
                },
                4: { // Left Sidepod
                    position: [-4.83, 5.4, 1.65],
                    target: [1.24, 3.84, 2.04]
                },
                5: { // Underfloor (swapped)
                    position: [0.17, -1.99, 2.25],
                    target: [0.17, 1.87, 1.96]
                },
                6: { // Rear Wing (swapped)
                    position: [-0.04, 6.09, -2.39],
                    target: [-0.13, 3.6, 1.11]
                }
            };
            
            const pos = cameraPositions[annotation.id];
            if (pos) {
                // Smoothly move camera to the annotation using existing animator
                const durationMs = 1400;
                animateCamera(pos.position, pos.target, durationMs);
                console.log(`Animating to ${annotation.name} - using walkthrough position`);
            }
            
            resetIdleTimer();
        }

        function showAnnotations() {
            if (ui.annotationPanel) {
                ui.annotationPanel.classList.add('visible');
            }
        }

        function hideAnnotations() {
            if (ui.annotationPanel) {
                ui.annotationPanel.classList.remove('visible');
            }
            if (ui.annotationContent) {
                ui.annotationContent.innerHTML = '';
            }
        }

        // ====== WALKTHROUGH SYSTEM ======
        // Load walkthrough audio
        function loadWalkthroughAudio() {
            return new Promise((resolve, reject) => {
                walkthroughAudio = new Audio('walkthrough-complete.mp3');
                
                walkthroughAudio.addEventListener('loadedmetadata', () => {
                    console.log(`Walkthrough audio loaded: ${walkthroughAudio.duration} seconds`);
                    resolve();
                });
                
                walkthroughAudio.addEventListener('error', (e) => {
                    console.warn('Failed to load walkthrough audio:', e);
                    reject(e);
                });
                
                // Start loading
                walkthroughAudio.load();
            });
        }

        // Start walkthrough
        async function startWalkthrough() {
            if (walkthroughActive || currentIndex !== 0) return;
            
            console.log('Starting walkthrough...');
            walkthroughActive = true;
            ui.walkthrough.classList.add('active');
            ui.walkthrough.textContent = 'STOP WALKTHROUGH';
            
            // Store current background and always restore to original for walkthrough
            window.storedBackground = scene.background.clone();
            scene.background = new THREE.Color(0x0a0a0a);
            console.log('Walkthrough background set to original dark');
            
            // Hide UI elements
            ui.topBar.style.opacity = '0';
            ui.prev.style.opacity = '0';
            ui.next.style.opacity = '0';
            ui.instructions.style.opacity = '0';
            hideAnnotations();
            hideLiveryPanel();
            
            // Disable user controls
            controls.enabled = false;
            controls.autoRotate = false;
            ui.auto.classList.remove('active');
            clearTimeout(idleTimer);
            
            // Load and start audio
            try {
                await loadWalkthroughAudio();
                executeWalkthroughSequence();
            } catch (error) {
                console.error('Failed to load walkthrough audio, using text-only mode');
                executeWalkthroughSequence();
            }
        }
        
        // Execute walkthrough sequence
        function executeWalkthroughSequence() {
            let stepIndex = 0;
            let audioStarted = false;
            
            function executeStep() {
                if (!walkthroughActive || stepIndex >= WALKTHROUGH_SCRIPT.length) {
                    if (stepIndex >= WALKTHROUGH_SCRIPT.length) {
                        console.log('Walkthrough completed');
                        endWalkthrough();
                    }
                    return;
                }
                
                const step = WALKTHROUGH_SCRIPT[stepIndex];
                const stepNumber = stepIndex + 1;
                const timing = WALKTHROUGH_TIMINGS[stepIndex];
                
                console.log(`Step ${stepNumber}/${WALKTHROUGH_SCRIPT.length}: Moving to position`, step.camera.position);
                
                // Show subtitles
                showSubtitles(step.text);
                
                // Smooth camera transition to position and STAY THERE
                const transitionTime = stepIndex === 0 ? 2000 : 1500;
                animateCamera(step.camera.position, step.camera.target, transitionTime);
                
                // Start audio on first step only
                if (!audioStarted && walkthroughAudio) {
                    walkthroughAudio.currentTime = 0;
                    walkthroughAudio.play().then(() => {
                        console.log('Walkthrough audio started');
                    }).catch(e => {
                        console.warn('Failed to play walkthrough audio:', e);
                    });
                    audioStarted = true;
                }
                
                // Wait for this step's duration
                const stepDuration = timing.duration * 1000;
                speechTimeoutId = setTimeout(() => {
                    if (!walkthroughActive) return;
                    
                    console.log(`Step ${stepNumber} completed`);
                    
                    // Move to next step
                    stepIndex++;
                    executeStep();
                }, stepDuration);
            }
            
            // Start with a brief delay
            setTimeout(() => {
                if (walkthroughActive) {
                    executeStep();
                }
            }, 1000);
        }
        
        // Stop walkthrough
        function stopWalkthrough() {
            if (!walkthroughActive) return;
            
            console.log('Stopping walkthrough...');
            walkthroughActive = false;
            
            // Stop audio
            cleanupAudio();
            
            // Clear any pending animations
            if (walkthroughAnimation) {
                clearTimeout(walkthroughAnimation);
                walkthroughAnimation = null;
            }
            
            endWalkthrough();
        }
        
        // End walkthrough
        function endWalkthrough() {
            console.log('Ending walkthrough');
            walkthroughActive = false;
            
            // Clean up audio completely
            cleanupAudio();
            
            // Restore stored background if it exists
            if (window.storedBackground) {
                scene.background = window.storedBackground.clone();
                console.log('Restored background after walkthrough');
            }
            
            // Reset UI
            ui.walkthrough.classList.remove('active');
            ui.walkthrough.textContent = 'GUIDED WALKTHROUGH';
            hideSubtitles();
            
            // Restore UI elements
            ui.topBar.style.opacity = '1';
            ui.prev.style.opacity = '1';
            ui.next.style.opacity = '1';
            ui.instructions.style.opacity = '1';
            
            // Re-enable controls with auto-rotate
            controls.enabled = true;
            controls.autoRotate = true;
            ui.auto.classList.add('active');
            setCenteredAutoRotatePosition();
            
            // Restore annotations
            setTimeout(() => {
                createAnnotations();
                showAnnotations();
            }, 500);
            
            // Restart idle timer
            resetIdleTimer();
            
            console.log('Walkthrough ended successfully');
        }
        
        // Show subtitles
        function showSubtitles(text) {
            if (ui.subtitles) {
                ui.subtitles.textContent = text;
                ui.subtitles.classList.add('visible');
            }
        }
        
        // Hide subtitles
        function hideSubtitles() {
            if (ui.subtitles) {
                ui.subtitles.classList.remove('visible');
                setTimeout(() => {
                    ui.subtitles.textContent = '';
                }, 500);
            }
        }
        
        // Animate camera
        function animateCamera(position, target, duration) {
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const targetPosition = new THREE.Vector3(...position);
            const targetTarget = new THREE.Vector3(...target);
            
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing
                const eased = progress < 0.5 
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                camera.position.lerpVectors(startPosition, targetPosition, eased);
                controls.target.lerpVectors(startTarget, targetTarget, eased);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            
            updateCamera();
        }

        // ====== IDLE TIMER SYSTEM ======
        function resetIdleTimer() {
            clearTimeout(idleTimer);
            
            if (appState === 'viewing' && !walkthroughActive) {
                idleTimer = setTimeout(() => {
                    if (appState === 'viewing' && !walkthroughActive) {
                        console.log('Idle timeout - returning to home screen');
                        returnHome();
                    }
                }, 10000); // 10 seconds of inactivity
            }
        }

        function setCenteredAutoRotatePosition() {
            if (!currentModel) return;
            
            console.log('Setting centered auto-rotate position...');
            
            // Get the actual car center for rotation point
            const box = new THREE.Box3().setFromObject(currentModel);
            const carCenter = box.getCenter(new THREE.Vector3());
            
            // Set auto-rotate position
            camera.position.set(-4.86, 10.6, 0);
            
            // Pan the rotation center down a bit
            const rotationCenter = new THREE.Vector3(
                carCenter.x, 
                carCenter.y + 1.75,
                carCenter.z
            );
            
            controls.target.copy(rotationCenter);
            camera.lookAt(controls.target);
            controls.update();
            
            console.log('Auto-rotate set - centered position');
        }

        // ====== MODEL SYSTEM ======
        // Create a simple F1 car model (fallback)
        function createCarModel() {
            const group = new THREE.Group();
            
            // Main chassis
            const chassisGeometry = new THREE.BoxGeometry(1.8, 0.3, 4.5);
            const chassisMaterial = new THREE.MeshPhongMaterial({ color: 0x0066cc });
            const chassis = new THREE.Mesh(chassisGeometry, chassisMaterial);
            chassis.position.y = 0.15;
            chassis.castShadow = true;
            chassis.name = 'chassis';
            group.add(chassis);
            
            // Cockpit
            const cockpitGeometry = new THREE.BoxGeometry(1.2, 0.4, 1.8);
            const cockpitMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.5, 0.5);
            cockpit.castShadow = true;
            cockpit.name = 'cockpit';
            group.add(cockpit);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            const positions = [
                [-1.1, 0.35, 1.6],   // Front left
                [1.1, 0.35, 1.6],    // Front right
                [-1.2, 0.4, -1.6],   // Rear left
                [1.2, 0.4, -1.6]     // Rear right
            ];
            
            positions.forEach((pos, i) => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                wheel.name = `wheel_${i}`;
                group.add(wheel);
            });
            
            // Front wing
            const frontWingGeometry = new THREE.BoxGeometry(2.2, 0.08, 0.8);
            const frontWingMaterial = new THREE.MeshPhongMaterial({ color: 0xf32411 });
            const frontWing = new THREE.Mesh(frontWingGeometry, frontWingMaterial);
            frontWing.position.set(0, 0.1, 2.1);
            frontWing.castShadow = true;
            frontWing.name = 'front_wing';
            group.add(frontWing);
            
            // Rear wing
            const rearWingGeometry = new THREE.BoxGeometry(1.8, 0.1, 0.6);
            const rearWing = new THREE.Mesh(rearWingGeometry, frontWingMaterial);
            rearWing.position.set(0, 0.8, -2.1);
            rearWing.castShadow = true;
            rearWing.name = 'rear_wing';
            group.add(rearWing);
            
            // Side pods
            const sidePodGeometry = new THREE.BoxGeometry(0.6, 0.4, 2);
            const sidePodMaterial = new THREE.MeshPhongMaterial({ color: 0x0088ff });
            
            const leftSidePod = new THREE.Mesh(sidePodGeometry, sidePodMaterial);
            leftSidePod.position.set(-0.8, 0.2, 0);
            leftSidePod.castShadow = true;
            leftSidePod.name = 'left_sidepod';
            group.add(leftSidePod);
            
            const rightSidePod = new THREE.Mesh(sidePodGeometry, sidePodMaterial);
            rightSidePod.position.set(0.8, 0.2, 0);
            rightSidePod.castShadow = true;
            rightSidePod.name = 'right_sidepod';
            group.add(rightSidePod);
            
            return group;
        }

        function enhanceMaterial(material) {
            if (Array.isArray(material)) {
                material.forEach(mat => {
                    mat.metalness = Math.min(mat.metalness || 0, 0.8);
                    mat.roughness = Math.max(mat.roughness || 0.4, 0.2);
                    mat.needsUpdate = true;
                });
            } else {
                material.metalness = Math.min(material.metalness || 0, 0.8);
                material.roughness = Math.max(material.roughness || 0.4, 0.2);
                material.needsUpdate = true;
            }
        }

        function positionModel(model, modelIndex) {
            // Reset transformations
            model.position.set(0, 0, 0);
            model.scale.set(1, 1, 1);
            model.rotation.set(0, 0, 0);
            model.updateMatrixWorld(true);
            
            // Apply rotation based on model index
            if (modelIndex > 0) { // iterations 2-5 (indices 1-4)
                model.rotation.set(3*Math.PI/2, 0, 0);
                model.updateMatrixWorld(true);
            }
            // iteration 1 (index 0) keeps [0, 0, 0] rotation
            
            // Get bounding box
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            // Scale to appropriate size
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 4;
            const scale = targetSize / maxDim;
            model.scale.setScalar(scale);
            model.updateMatrixWorld(true);
            
            // Recalculate bounding box after scaling
            const scaledBox = new THREE.Box3().setFromObject(model);
            const scaledSize = scaledBox.getSize(new THREE.Vector3());
            
            // Position model so its bottom sits on the ground plane
            model.position.y = -scaledBox.min.y;
            model.position.x = -scaledBox.getCenter(new THREE.Vector3()).x;
            model.position.z = -scaledBox.getCenter(new THREE.Vector3()).z;
            model.updateMatrixWorld(true);
            
            // Update controls target to center of model above ground
            controls.target.set(0, scaledSize.y / 2, 0);
            controls.update();
        }

        function setupModel(model) {
            currentModel = model;
            
            // Enhance materials and enable shadows
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    if (child.material) {
                        enhanceMaterial(child.material);
                    }
                }
            });
            
            // Position model
            positionModel(currentModel, currentIndex);
            scene.add(currentModel);
            
            // Store original materials for livery system
            storeOriginalMaterials(currentModel);
            
            // Apply current livery if not original
            if (currentLivery !== 'original') {
                setTimeout(() => applyLivery(currentLivery), 100);
            }
            
            // Immediately set auto-rotate position when model is ready
            controls.autoRotate = true;
            ui.auto.classList.add('active');
            setCenteredAutoRotatePosition();
            
            // Show walkthrough button only on iteration 1
            if (currentIndex === 0) {
                ui.walkthrough.style.display = 'flex';
            } else {
                ui.walkthrough.style.display = 'none';
            }
            
            // Create annotations
            createAnnotations();
            
            ui.loader.style.display = 'none';
            console.log('Model setup complete - auto-rotate enabled');
        }

        // GLB Loader setup
        const gltfLoader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        dracoLoader.setDecoderConfig({ type: 'js' });
        gltfLoader.setDRACOLoader(dracoLoader);

        // Load and display model
        function loadModel(index) {
            ui.loader.style.display = 'block';
            
            // Update UI
            const iteration = ITERATIONS[index];
            ui.iterationTitle.textContent = iteration.title;
            ui.iterationSubtitle.textContent = iteration.subtitle;
            
            // Update dropdown selection
            ui.iterationDropdown.value = index;
            
            const specsHtml = Object.entries(iteration.specs).map(([key, value]) => 
                `<div class="spec-line">${key}: <span class="spec-highlight">${value}</span></div>`
            ).join('');
            ui.specsInfo.innerHTML = specsHtml;
            
            // Remove existing model
            if (currentModel) {
                scene.remove(currentModel);
                disposeModel(currentModel);
            }
            
            // Clean up wind tunnel
            if (windTunnel) {
                windTunnel.destroy();
                windTunnel = null;
                windTunnelActive = false;
                ui.windTunnel.classList.remove('active');
                ui.windTunnel.title = 'Enable Wind Tunnel';
            }
            
            // Try to load GLB first, fallback to procedural model
            gltfLoader.load(
                MODELS[index],
                (gltf) => {
                    console.log(`GLB model ${MODELS[index]} loaded successfully`);
                    setupModel(gltf.scene);
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100);
                    console.log(`Loading ${MODELS[index]} progress:`, percent + '%');
                },
                (error) => {
                    console.warn(`Could not load GLB ${MODELS[index]}, using fallback:`, error);
                    setupModel(createCarModel());
                }
            );
        }

        // ====== NAVIGATION SYSTEM ======
        function switchIteration(direction) {
            const newIndex = direction === 'next' 
                ? Math.min(currentIndex + 1, ITERATIONS.length - 1)
                : Math.max(currentIndex - 1, 0);
                
            if (newIndex !== currentIndex) {
                currentIndex = newIndex;
                loadModel(currentIndex);
                updateNavigationButtons();
                resetIdleTimer();
            }
        }

        function updateNavigationButtons() {
            ui.prev.classList.toggle('disabled', currentIndex === 0);
            ui.next.classList.toggle('disabled', currentIndex === ITERATIONS.length - 1);
        }

        // ====== UI FUNCTIONS ======
        function showViewer() {
            console.log('Showing viewer');
            ui.home.style.display = 'none';
            ui.topBar.style.display = 'flex';
            ui.prev.style.display = 'flex';
            ui.next.style.display = 'flex';
            ui.instructions.style.display = 'block';
            ui.welcome.style.display = 'flex';
            
            updateNavigationButtons();
            loadModel(currentIndex);
            appState = 'loading';
        }

        function startViewing() {
            console.log('Starting viewing');
            ui.welcome.style.display = 'none';
            controls.enabled = true;
            controls.autoRotate = true;
            ui.auto.classList.add('active');
            setCenteredAutoRotatePosition();
            resetIdleTimer();
            appState = 'viewing';
        }

        function returnHome() {
            console.log('Returning home');
            clearTimeout(idleTimer);
            
            // Stop walkthrough if active
            if (walkthroughActive) {
                stopWalkthrough();
            }
            
            // Deactivate wind tunnel
            if (windTunnelActive) {
                toggleWindTunnel();
            }
            
            controls.enabled = false;
            controls.autoRotate = false;
            ui.auto.classList.remove('active');
            
            if (currentModel) {
                scene.remove(currentModel);
                disposeModel(currentModel);
                currentModel = null;
            }
            
            hideAnnotations();
            hideSubtitles();
            hideLiveryPanel();
            ui.topBar.style.display = 'none';
            ui.prev.style.display = 'none';
            ui.next.style.display = 'none';
            ui.instructions.style.display = 'none';
            ui.welcome.style.display = 'none';
            ui.walkthrough.style.display = 'none';
            ui.home.style.display = 'flex';
            appState = 'home';
            currentIndex = 0; // Reset to iteration 1
        }

        // ====== THREE.JS SCENE SETUP ======
        function initScene() {
            const canvas = document.getElementById('c');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 10, 25);
            
            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 10, 15);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            // Lower effective pixel ratio slightly on low-latency touch screens for smoother feel
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            // Increase damping slightly to smooth motion on laggy touchscreens
            controls.dampingFactor = 0.08;
            controls.minDistance = 3;
            controls.maxDistance = 40;
            // Slightly exaggerate touch rotate/pan/zoom responsiveness
            controls.rotateSpeed = 1.1;
            controls.zoomSpeed = 1.1;
            controls.panSpeed = 1.2;
            // Slightly faster auto-rotate to maintain responsiveness feel
            controls.autoRotateSpeed = 2.4;
            controls.enabled = false; // Start disabled
            
            // Control event listeners for idle timer
            controls.addEventListener('start', () => {
                if (controls.autoRotate) {
                    controls.autoRotate = false;
                    ui.auto.classList.remove('active');
                }
                resetIdleTimer();
            });
            
            controls.addEventListener('change', resetIdleTimer);
            
            // Lighting - Enhanced with multiple spotlights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(hemisphereLight);
            
            // Main directional light (brighter)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(10, 15, 8);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 40;
            directionalLight.shadow.camera.left = -15;
            directionalLight.shadow.camera.right = 15;
            directionalLight.shadow.camera.top = 15;
            directionalLight.shadow.camera.bottom = -15;
            scene.add(directionalLight);
            
            // Multiple spotlights for dramatic lighting
            const spotlightConfigs = [
                { pos: [15, 10, 10], color: 0xffffff, intensity: 1.5 },
                { pos: [-15, 10, 10], color: 0xffffff, intensity: 1.5 },
                { pos: [0, 15, -10], color: 0xffffff, intensity: 1.2 },
                { pos: [10, 8, -15], color: 0xff9999, intensity: 1.0 },
                { pos: [-10, 8, -15], color: 0x9999ff, intensity: 1.0 },
                { pos: [0, 20, 0], color: 0xffffff, intensity: 1.8 }
            ];
            
            spotlightConfigs.forEach(config => {
                const spotlight = new THREE.SpotLight(config.color, config.intensity);
                spotlight.position.set(config.pos[0], config.pos[1], config.pos[2]);
                spotlight.target.position.set(0, 2, 0);
                spotlight.angle = Math.PI / 4;
                spotlight.penumbra = 0.3;
                spotlight.decay = 2;
                spotlight.distance = 50;
                spotlight.castShadow = true;
                
                // Add target to scene
                scene.add(spotlight.target);
                scene.add(spotlight);
            });
            
            // Additional fill lights for color enhancement
            const fillLight1 = new THREE.DirectionalLight(0x4488ff, 0.8);
            fillLight1.position.set(-10, 5, -10);
            scene.add(fillLight1);
            
            const fillLight2 = new THREE.DirectionalLight(0xff8844, 0.8);
            fillLight2.position.set(10, -2, 10);
            scene.add(fillLight2);
            
            const fillLight3 = new THREE.DirectionalLight(0x88ff44, 0.6);
            fillLight3.position.set(0, -5, 15);
            scene.add(fillLight3);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            console.log('Scene initialized successfully');
        }

        // ====== EVENT LISTENERS ======
        function setupEventListeners() {
            // Home screen click
            ui.home.addEventListener('click', function(event) {
                console.log('Home screen clicked');
                event.preventDefault();
                if (appState === 'home') {
                    showViewer();
                }
            });
            
            // Welcome screen click
            ui.welcome.addEventListener('click', function(event) {
                console.log('Welcome clicked');
                event.preventDefault();
                if (appState === 'loading') {
                    startViewing();
                }
            });
            
            // Navigation buttons
            ui.prev.addEventListener('click', function(event) {
                event.stopPropagation();
                if (!ui.prev.classList.contains('disabled')) {
                    switchIteration('prev');
                }
            });
            
            ui.next.addEventListener('click', function(event) {
                event.stopPropagation();
                if (!ui.next.classList.contains('disabled')) {
                    switchIteration('next');
                }
            });
            
            // Control buttons
            ui.auto.addEventListener('click', function(event) {
                event.stopPropagation();
                if (walkthroughActive) return; // Disable during walkthrough
                
                controls.autoRotate = !controls.autoRotate;
                ui.auto.classList.toggle('active', controls.autoRotate);
                
                if (controls.autoRotate) {
                    setCenteredAutoRotatePosition();
                }
                resetIdleTimer();
            });
            
            ui.livery.addEventListener('click', function(event) {
                event.stopPropagation();
                toggleLiveryPanel();
            });
            
            ui.windTunnel.addEventListener('click', function(event) {
                event.stopPropagation();
                toggleWindTunnel();
            });
            
            ui.walkthrough.addEventListener('click', function(event) {
                event.stopPropagation();
                if (currentIndex !== 0) return; // Only available on iteration 1
                
                if (walkthroughActive) {
                    stopWalkthrough();
                } else {
                    startWalkthrough();
                }
            });
            
            ui.reset.addEventListener('click', function(event) {
                event.stopPropagation();
                returnHome();
            });
            
            // Iteration dropdown
            ui.iterationDropdown.addEventListener('change', function(event) {
                event.stopPropagation();
                const selectedIndex = parseInt(event.target.value);
                if (selectedIndex !== currentIndex) {
                    currentIndex = selectedIndex;
                    loadModel(currentIndex);
                    updateNavigationButtons();
                    resetIdleTimer();
                }
            });
            
            // Keyboard navigation
            document.addEventListener('keydown', function(event) {
                if (appState === 'viewing') {
                    switch(event.key) {
                        case 'ArrowLeft':
                            event.preventDefault();
                            if (!ui.prev.classList.contains('disabled')) {
                                switchIteration('prev');
                            }
                            break;
                        case 'ArrowRight':
                            event.preventDefault();
                            if (!ui.next.classList.contains('disabled')) {
                                switchIteration('next');
                            }
                            break;
                        case ' ':
                            event.preventDefault();
                            if (currentIndex === 0) {
                                ui.walkthrough.click();
                            } else {
                                ui.auto.click();
                            }
                            break;
                        case 'Escape':
                            event.preventDefault();
                            if (walkthroughActive) {
                                stopWalkthrough();
                            } else {
                                returnHome();
                            }
                            break;
                    }
                }
            });
            
            // Window resize
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Track interactions for idle timer
            const interactionEvents = [
                'mousedown', 'mouseup', 'mousemove', 'click',
                'touchstart', 'touchmove', 'touchend',
                'wheel', 'keydown'
            ];
            
            interactionEvents.forEach(event => {
                renderer.domElement.addEventListener(event, () => {
                    if (appState === 'viewing') {
                        resetIdleTimer();
                    }
                }, { passive: true });
            });
            
            console.log('Event listeners set up successfully');
        }

        // ====== ANIMATION LOOP ======
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            // Update wind tunnel
            if (windTunnel && windTunnelActive) {
                windTunnel.update();
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // ====== INITIALIZATION ======
        function init() {
            console.log('Initializing Aeros Racing Pit Display...');
            
            try {
                initScene();
                setupEventListeners();
                createLiveryPanel();
                animate();
                console.log('Application initialized successfully');
                console.log('Current state:', appState);
            } catch (error) {
                console.error('Initialization error:', error);
            }
        }

        // Start the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
